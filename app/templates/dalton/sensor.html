{% extends "dalton/layout.html" %}
{% block body %}
    <div class="row">
        <div class="span11">
            <h2>Sensors</h2>
            <p id="sensors-last-updated" class="text-muted" style="font-size: 0.85em;"></p>
            <table class="table table-striped">
                <thead>
                    <tr>
                        <th>Sensor ID</th>
                        <th>Technology</th>
                        <th>Agent Version</th>
                        <th>IP Address</th>
                        <th>Last Heartbeat</th>
                    </tr>
                </thead>
                <tbody id="sensors-table-body">
		{% for sensor,data in sensors.items() %}
			<tr>
				<td>{{ data.uid }}</td>
				<td>
                {% set tlist = data.tech.split('/') %}
                {% if tlist|length > 1 %}
                    {% if tlist[1].startswith("rust_") %}
                        {{tlist[0]|title}} {{tlist[1][5:]}} ({% if tlist|length > 2 %}{{tlist[2]}} - {% endif %}with Rust support)
                    {% else %}
                        {{tlist[0]|title}} {{tlist[1]}}{% if tlist|length > 2 %} ({{tlist[2]}}){% endif %}
                    {% endif %}
                {% else %}
                    {{data.tech|title}}
                {% endif %}
				</td>
                <td>{{ data.agent_version }}</td>
				<td>{{ data.ip }}</td>
				<td>{{ data.time }}</td>
			</tr>
		{% endfor %}
                </tbody>
            </table>
        </div>
    </div>

    <script type="text/javascript">
    (function() {
        var POLL_INTERVAL = 5000; // 5 seconds
        var tracker = DaltonUtils.createLastUpdatedTracker('sensors-last-updated');

        function rebuildSensorsTable(sensors) {
            var tbody = document.getElementById('sensors-table-body');
            if (!tbody) return;

            var rows = [];
            for (var sensorKey in sensors) {
                if (sensors.hasOwnProperty(sensorKey)) {
                    var data = sensors[sensorKey];
                    var row = '<tr>' +
                        '<td>' + DaltonUtils.escapeHtml(data.uid) + '</td>' +
                        '<td>' + DaltonUtils.escapeHtml(DaltonUtils.formatTechnology(data.tech)) + '</td>' +
                        '<td>' + DaltonUtils.escapeHtml(data.agent_version) + '</td>' +
                        '<td>' + DaltonUtils.escapeHtml(data.ip) + '</td>' +
                        '<td>' + DaltonUtils.escapeHtml(data.time) + '</td>' +
                        '</tr>';
                    rows.push(row);
                }
            }

            if (rows.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="text-center">No active sensors</td></tr>';
            } else {
                tbody.innerHTML = rows.join('');
            }
        }

        function pollSensors() {
            $.ajax({
                url: '/dalton/controller_api/get-current-sensors-json-full',
                method: 'GET',
                dataType: 'json',
                success: function(sensors) {
                    rebuildSensorsTable(sensors);
                    tracker.markUpdated();
                },
                error: function(xhr, status, error) {
                    console.error('Failed to fetch sensors:', error);
                    // Don't clear table on error - keep stale data visible
                }
            });
        }

        // Initialize
        DaltonUtils.createPoller(pollSensors, POLL_INTERVAL).start();
    })();
    </script>
{% endblock %}
